libraryIEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- MUX8 ==================================================================================

entity mux8_16bit is
	Port(	In0, In1, In2, In3, In4, In5, In6, In7: in std_logic_vector(15 downto 0);
		S0, S1, S2: in std_logic;
		Z: out std_logic_vector(15 downto 0));
end mux8_16bit;

architecture behavioural of mux8_16bit is
begin
Z <= 	In0 after 5ns when S0 = '0' and S1 = '0' and S2 = '0' else
     	In1 after 5ns when S0 = '0' and S1 = '0' and S2 = '1' else
	In2 after 5ns when S0 = '0' and S1 = '1' and S2 = '0' else
	In3 after 5ns when S0 = '0' and S1 = '1' and S2 = '1' else
	In4 after 5ns when S0 = '1' and S1 = '0' and S2 = '0' else
     	In5 after 5ns when S0 = '1' and S1 = '0' and S2 = '1' else
	In6 after 5ns when S0 = '1' and S1 = '1' and S2 = '0' else
	In7 after 5ns when S0 = '1' and S1 = '1' and S2 = '1' else
	"0000000000000000" after 5ns;
end behavioural;

-- MUX4 ==================================================================================

entity mux2_16bit is
	Port(	In0, In1: in std_logic(15 downto 0);
		S: in std_logic;
		Z: out std_logic_vector(15 downto 0));
end mux2_16bit;

architecture behavioural of mux2_16bit is
begin
Z <= 	In0 after 5ns when S = '0' else
	In1 after 5ns when S = '1' else
	"0000000000000000" after 5ns;
end behavioural;

-- REG ==================================================================================

entity reg8_16bit is
	Port(	D0, D1, D2, D3, D4, D5, D6, D7: in std_logic_vector(15 downto 0);
		Q0, Q1, Q2, Q3 ,Q4, Q5, Q6, Q7: out std_logic_vector(15 downto 0);
		load0, load1, load2, load3, load4, load5, load6, load7: in std_logic;
		clk: in std_logic);
end reg8_16bit;

architecture behavioural of reg8_16bit is 
	component reg16
		Port(	D: in std_logic_vector(15 downto 0);
			Q: out std_logic_vector(15 downto 0);
			load: in std_logic;
			clk: in std_logic);
	end component;
begin
	reg0: reg16
		port map(D0, Q0, load0, clk);
	reg1: reg16
		port map(D1, Q1, load1, clk);
	reg2: reg16
		port map(D2, Q2, load2, clk);
	reg3: reg16
		port map(D3, Q3, load3, clk);
	reg4: reg16
		port map(D4, Q4, load4, clk);
	reg5: reg16
		port map(D5, Q5, load5, clk);
	reg6: reg16
		port map(D6, Q6, load6, clk);
	reg7: reg16
		port map(D7, Q7, load7, clk);
Q <= 	D after 5ns when load = '1' and clk'event and clk='1' else
	"0000000000000000" after 5ns;
end behavioural;

-- DEC ==================================================================================

entity decoder is
	Port(	A0, A1, A2: in std_logic;
		Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7: out std_logic);
end decoder;

architecture behavioural of decoder is
begin
Q0 <= not A0 and not A1 and not A2 after 5ns;
Q1 <= not A0 and not A1 and A2 after 5ns;
Q2 <= not A0 and A1 and not A2 after 5ns;
Q3 <= not A0 and A1 and A2 after 5ns;
Q4 <= A0 and not A1 and not A2 after 5ns;
Q5 <= A0 and not A1 and A2 after 5ns;
Q6 <= A0 and A1 and not A2 after 5ns;
Q7 <= A0 and A1 and A2 after 5ns;
end behavioural;

-- And in the darkness BIND them ==================================================================================

entity registerFile is
	Port(	src_SO, src_S1, des_A0, des_A1, des_A2, clk, data_src: in std_logic;
		data: in std_logic_vector(15 downto 0);
		reg0_out, reg1_out, reg2_out, reg3_out, reg4_out, reg5_out, reg6_out, reg7_out);
end registerFile;

architecture behavioural of registerFile is
	signal dec_outQ0, dec_outQ1, dec_outQ2, dec_outQ3, dec_outQ4, dec_outQ5, dec_outQ6, dec_outQ7: std_logic;
	signal mux2_out, mux8_out, reg0Q, reg1Q, reg2Q, reg3Q, reg4Q, reg5Q, reg6Q, reg7Q: std_logic_vector(15 downto 0);
begin
	m8a: mux8_16bit port map(S0 => src_S0);
	m8b: mux8_16bit port map(S1 => src_S1);
	m8c: mux8_16bit port map(Z => mux8_out);
	m2a: mux2_16bit port map(In1 => mux8_out);
	m2b: mux2_16bit port map(Z => mux2_out);
	m2c: mux2_16bit port map(In0 => data);
	m2d: mux2_16bit port map(S => data_src);

	decIa: decoder port map(A0 => des_A0);
	decIb: decoder port map(A1 => des_A1);

	deca: decoder port map(Q0 => dec_outQ0);
	decc: decoder port map(Q1 => dec_outQ1);
	decd: decoder port map(Q2 => dec_outQ2);
	dece: decoder port map(Q3 => dec_outQ3);
	decf: decoder port map(Q4 => dec_outQ4);
	decg: decoder port map(Q5 => dec_outQ5);
	dech: decoder port map(Q6 => dec_outQ6);
	deci: decoder port map(Q7 => dec_outQ7);

	rega: reg0 port map(load0 => dec_outQ0);
	regc: reg1 port map(load1 => dec_outQ1);
	regd: reg2 port map(load2 => dec_outQ2);
	rege: reg3 port map(load3 => dec_outQ3);
	regf: reg4 port map(load4 => dec_outQ4);
	regg: reg5 port map(load5 => dec_outQ5);
	regh: reg6 port map(load6 => dec_outQ6);
	regi: reg7 port map(load7 => dec_outQ7);

	regj: reg0 port map(D0 => mux2_out);
	regk: reg1 port map(D1 => mux2_out);
	regl: reg2 port map(D2 => mux2_out);
	regm: reg3 port map(D3 => mux2_out);
	regn: reg4 port map(D4 => mux2_out);
	rego: reg5 port map(D5 => mux2_out);
	regp: reg6 port map(D6 => mux2_out);
	regq: reg7 port map(D7 => mux2_out);

	regr: reg0 port map(Q0 => reg0Q);
	regs: reg1 port map(Q1 => reg1Q);
	regt: reg2 port map(Q2 => reg2Q);
	regu: reg3 port map(Q3 => reg3Q);
	regv: reg4 port map(Q4 => reg4Q);
	regw: reg5 port map(Q5 => reg5Q);
	regx: reg6 port map(Q6 => reg6Q);
	regy: reg7 port map(Q7 => reg7Q);
	
	m8d: mux8_16bit port map(In0 => reg0Q);
	m8e: mux8_16bit port map(In1 => reg1Q);
	m8f: mux8_16bit port map(In2 => reg2Q);
	m8g: mux8_16bit port map(In3 => reg3Q);
	m8h: mux8_16bit port map(In4 => reg4Q);
	m8i: mux8_16bit port map(In5 => reg5Q);
	m8j: mux8_16bit port map(In6 => reg6Q);
	m8k: mux8_16bit port map(In7 => reg7Q);
	
end behavioural;
